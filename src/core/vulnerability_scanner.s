.data
    # Menu and prompts
    welcome:        .asciiz "\n=== MIPS Security Analysis Tool ===\n"
    file_prompt:    .asciiz "Enter path to assembly file: "
    menu:          .asciiz "\n1. Display loaded code\n2. Scan for vulnerabilities\n3. Exploit Repository\n4. Exit\nChoice: "
    
    # Exploit menu
    exploit_menu_text:   .asciiz "\nExploit Repository Menu:\n1. Buffer Overflow\n2. Memory Leak\n3. Memory Access Attacks\n4. Return to main menu\nSelect topic: "
    
    # Status messages
    loading_msg:    .asciiz "\nLoading file...\n"
    error_msg:      .asciiz "Error: Could not open file\n"
    read_error_msg: .asciiz "Error: Could not read file\n"
    size_error_msg: .asciiz "Error: File too large\n"
    scan_msg:       .asciiz "\nScanning for vulnerabilities...\n"
    no_vuln_msg:    .asciiz "No vulnerabilities detected.\n"
    
    # Vulnerability messages
    vuln_header:    .asciiz "\n=== Vulnerability Report ===\n"
    buffer_vuln:    .asciiz "WARNING: Potential buffer overflow risk - Large buffer allocation\n"
    syscall_vuln:   .asciiz "WARNING: Unsafe system call usage - Unvalidated input\n"
    memory_vuln:    .asciiz "WARNING: Unprotected memory access - Direct memory operation\n"
    
    # Repository Info
    buffer_info:     .asciiz "\n=== Buffer Overflow Vulnerabilities ===\n\nDescription:\nBuffer overflow vulnerabilities occur when a program writes data beyond the bounds\nof allocated memory. This can corrupt adjacent memory and potentially allow\nmalicious code execution.\n\nCommon Attack Methods:\n1. Stack Overflow - Overwriting return addresses\n2. Heap Overflow - Corrupting heap metadata\n3. Off-by-One Errors - Writing just past buffer bounds\n\nPrevention:\n- Use bounded string operations\n- Implement proper bounds checking\n- Enable stack protection mechanisms\n- Validate all input lengths\n\n"
    
    memory_info:     .asciiz "\n=== Memory Leak Vulnerabilities ===\n\nDescription:\nMemory leaks occur when programs fail to properly free allocated memory,\npotentially exposing sensitive information and causing resource exhaustion.\n\nCommon Attack Methods:\n1. Use-After-Free - Accessing freed memory\n2. Double Free - Corrupting memory management\n3. Null Pointer Dereference\n\nPrevention:\n- Proper memory management\n- Secure memory wiping\n- Implement RAII patterns\n- Use memory analysis tools\n\n"
    
    mem_access_info: .asciiz "\n=== Memory Access Vulnerabilities ===\n\nDescription:\nImproper memory access can lead to unauthorized data access and system crashes.\nThis includes reading/writing to invalid or protected memory regions.\n\nCommon Attack Methods:\n1. Out-of-bounds Access\n2. Uninitialized Memory Access\n3. Race Conditions\n\nPrevention:\n- Memory protection mechanisms\n- Input validation\n- Proper pointer handling\n- Access control checks\n\n"
    
    # Storage
    filepath:       .space 256      # Buffer for file path
    code_buffer:    .space 4096     # Buffer for source code
    overflow_payload: .asciiz "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"  # 40 'A's
    vuln_count:     .word 0         # Number of vulnerabilities found
    vuln_types:     .space 16       # Track vulnerability types
    newline:        .asciiz "\n"

    # Constants
    MAX_FILE_SIZE: .word 4096    # Maximum file size we can handle

.text
.globl main

main:
    # Save return address
    addi $sp, $sp, -4
    sw $ra, ($sp)
    
    # Display welcome message
    li $v0, 4
    la $a0, welcome
    syscall
    
    # Load the file first
    jal load_file
    
    # Check for load errors
    bltz $v0, main_exit

menu_loop:
    # Display menu
    li $v0, 4
    la $a0, menu
    syscall
    
    # Get user choice
    li $v0, 5
    syscall
    move $t0, $v0
    
    # Handle menu selection
    beq $t0, 1, display_code
    beq $t0, 2, scan_code
    beq $t0, 3, exploit_menu
    beq $t0, 4, main_exit
    j menu_loop

main_exit:
    lw $ra, ($sp)
    addi $sp, $sp, 4
    j exit_program

load_file:
    # Save registers
    addi $sp, $sp, -12
    sw $ra, 8($sp)
    sw $s0, 4($sp)
    sw $s1, 0($sp)
    
    # Prompt for filename
    li $v0, 4
    la $a0, file_prompt
    syscall
    
    # Read filename
    li $v0, 8
    la $a0, filepath
    li $a1, 256
    syscall
    
    # Remove newline from filename
    la $t0, filepath
remove_newline:
    lb $t1, ($t0)
    beqz $t1, open_file
    beq $t1, 10, replace_newline
    addi $t0, $t0, 1
    j remove_newline
replace_newline:
    sb $zero, ($t0)
    
open_file:
    # Open the file
    li $v0, 13
    la $a0, filepath
    li $a1, 0          # Read-only flag
    li $a2, 0          # Mode (ignored)
    syscall
    
    # Check for errors
    bltz $v0, file_error_handler
    move $s0, $v0      # Save file descriptor
    
    # Read file contents
    li $v0, 14
    move $a0, $s0
    la $a1, code_buffer
    li $a2, 4096
    syscall
    
    # Check read result
    bltz $v0, read_error
    beqz $v0, read_error
    
    # Check file size
    lw $t0, MAX_FILE_SIZE
    bgt $v0, $t0, size_error
    
    move $s1, $v0    # Save bytes read
    
    # Null terminate buffer
    la $t0, code_buffer
    add $t0, $t0, $s1
    sb $zero, ($t0)
    
    # Close file
    li $v0, 16
    move $a0, $s0
    syscall
    
    # Display success message
    li $v0, 4
    la $a0, loading_msg
    syscall
    
    # Return success
    move $v0, $s1
    
load_file_exit:
    # Restore registers
    lw $s1, 0($sp)
    lw $s0, 4($sp)
    lw $ra, 8($sp)
    addi $sp, $sp, 12
    jr $ra

display_code:
    # Show the loaded code
    li $v0, 4
    la $a0, code_buffer
    syscall
    j menu_loop

scan_code:
    # Save registers
    addi $sp, $sp, -12
    sw $ra, 8($sp)
    sw $s0, 4($sp)
    sw $s1, 0($sp)
    
    # Reset vulnerability counter
    sw $zero, vuln_count
    
    # Show scanning message
    li $v0, 4
    la $a0, scan_msg
    syscall
    
    la $a0, vuln_header
    syscall
    
    # Perform vulnerability checks
    la $s0, code_buffer        # Load code buffer address
    li $s1, 0                  # Initialize counter
    
    # Check for .space directives (potential buffer overflows)
    jal scan_buffer_overflow
    
    # Check for syscalls (potential unsafe input)
    jal scan_syscall_usage
    
    # Check for memory operations
    jal scan_memory_ops
    
    # Check if vulnerabilities were found
    lw $t0, vuln_count
    beqz $t0, no_vulnerabilities
    
    # Restore registers and return
    lw $s1, 0($sp)
    lw $s0, 4($sp)
    lw $ra, 8($sp)
    addi $sp, $sp, 12
    j menu_loop

exploit_menu:
    # Display exploit repository menu
    li $v0, 4
    la $a0, exploit_menu_text
    syscall
    
    # Get repository choice
    li $v0, 5
    syscall
    move $t0, $v0
    
    beq $t0, 1, show_buffer_info
    beq $t0, 2, show_memory_info
    beq $t0, 3, show_mem_access_info
    beq $t0, 4, menu_loop
    j exploit_menu

show_buffer_info:
    # Display buffer overflow information
    li $v0, 4
    la $a0, buffer_info
    syscall
    j exploit_menu

show_memory_info:
    # Display memory leak information
    li $v0, 4
    la $a0, memory_info
    syscall
    j exploit_menu

show_mem_access_info:
    # Display memory access information
    li $v0, 4
    la $a0, mem_access_info
    syscall
    j exploit_menu

scan_buffer_overflow:
    # Save return address
    addi $sp, $sp, -4
    sw $ra, ($sp)
    
    # Look for ".space" directive
    la $s0, code_buffer
scan_space_loop:
    lb $t0, ($s0)
    beqz $t0, scan_space_done
    
    # Check for period
    beq $t0, 46, check_space_keyword
    
next_space_char:
    addi $s0, $s0, 1
    j scan_space_loop
    
scan_space_done:
    lw $ra, ($sp)
    addi $sp, $sp, 4
    jr $ra

check_space_keyword:
    # Check if followed by "space"
    lb $t0, 1($s0)
    bne $t0, 115, next_space_char  # 's'
    lb $t0, 2($s0)
    bne $t0, 112, next_space_char  # 'p'
    
    # Found .space directive, report vulnerability
    jal report_buffer_vulnerability
    j next_space_char

scan_syscall_usage:
    # Save return address
    addi $sp, $sp, -4
    sw $ra, ($sp)
    
    # Look for "syscall" instruction
    la $s0, code_buffer
scan_syscall_loop:
    lb $t0, ($s0)
    beqz $t0, scan_syscall_done
    
    # Check for 's'
    beq $t0, 115, check_syscall_keyword
    
next_syscall_char:
    addi $s0, $s0, 1
    j scan_syscall_loop
    
scan_syscall_done:
    lw $ra, ($sp)
    addi $sp, $sp, 4
    jr $ra

check_syscall_keyword:
    # Check if followed by "yscall"
    lb $t0, 1($s0)
    bne $t0, 121, next_syscall_char
    
    # Found syscall, report vulnerability
    jal report_syscall_vulnerability
    j next_syscall_char

scan_memory_ops:
    # Save return address
    addi $sp, $sp, -4
    sw $ra, ($sp)
    
    # Look for memory operations (lw, sw)
    la $s0, code_buffer
scan_mem_loop:
    lb $t0, ($s0)
    beqz $t0, scan_mem_done
    
    # Check for 'l' or 's'
    beq $t0, 108, check_load_op     # 'l'
    beq $t0, 115, check_store_op    # 's'
    
next_mem_char:
    addi $s0, $s0, 1
    j scan_mem_loop
    
scan_mem_done:
    lw $ra, ($sp)
    addi $sp, $sp, 4
    jr $ra

check_load_op:
    lb $t0, 1($s0)
    bne $t0, 119, next_mem_char     # 'w'
    jal report_memory_vulnerability
    j next_mem_char

check_store_op:
    lb $t0, 1($s0)
    bne $t0, 119, next_mem_char     # 'w'
    jal report_memory_vulnerability
    j next_mem_char

report_buffer_vulnerability:
    # Increment vulnerability counter
    lw $t0, vuln_count
    addi $t0, $t0, 1
    sw $t0, vuln_count
    
    # Report vulnerability
    li $v0, 4
    la $a0, buffer_vuln
    syscall
    jr $ra

report_syscall_vulnerability:
    # Increment vulnerability counter
    lw $t0, vuln_count
    addi $t0, $t0, 1
    sw $t0, vuln_count
    
    # Report vulnerability
    li $v0, 4
    la $a0, syscall_vuln
    syscall
    jr $ra

report_memory_vulnerability:
    # Increment vulnerability counter
    lw $t0, vuln_count
    addi $t0, $t0, 1
    sw $t0, vuln_count
    
    # Report vulnerability
    li $v0, 4
    la $a0, memory_vuln
    syscall
    jr $ra

no_vulnerabilities:
    li $v0, 4
    la $a0, no_vuln_msg
    syscall
    j menu_loop

file_error_handler:
    li $v0, 4
    la $a0, error_msg
    syscall
    li $v0, -1        # Return error code
    j load_file_exit

read_error:
    # Close file first
    li $v0, 16
    move $a0, $s0
    syscall
    
    # Display error message
    li $v0, 4
    la $a0, read_error_msg
    syscall
    li $v0, -1        # Return error code
    j load_file_exit

size_error:
    # Close file first
    li $v0, 16
    move $a0, $s0
    syscall
    
    # Display error message
    li $v0, 4
    la $a0, size_error_msg
    syscall
    li $v0, -1        # Return error code
    j load_file_exit

exit_program:
    li $v0, 10
    syscall