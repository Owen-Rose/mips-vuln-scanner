.data
    # Menu and prompts
    welcome:        .asciiz "\n=== MIPS Security Analysis Tool ===\n"
    file_prompt:    .asciiz "Enter path to assembly file: "
    menu:          .asciiz "\n1. Display loaded code\n2. Scan for vulnerabilities\n3. Simulate exploit\n4. Exit\nChoice: "
    
    # Exploit menu
    exploit_menu_text:   .asciiz "\nExploit Simulation Menu:\n1. Buffer Overflow\n2. Memory Leak\n3. Return to main menu\nSelect exploit: "
    
    # Status messages
    loading_msg:    .asciiz "\nLoading file...\n"
    error_msg:      .asciiz "Error: Could not open file\n"
    read_error_msg: .asciiz "Error: Could not read file\n"
    size_error_msg: .asciiz "Error: File too large\n"
    scan_msg:       .asciiz "\nScanning for vulnerabilities...\n"
    no_vuln_msg:    .asciiz "No vulnerabilities detected.\n"
    
    # Vulnerability messages
    vuln_header:    .asciiz "\n=== Vulnerability Report ===\n"
    buffer_vuln:    .asciiz "WARNING: Potential buffer overflow risk - Large buffer allocation\n"
    syscall_vuln:   .asciiz "WARNING: Unsafe system call usage - Unvalidated input\n"
    memory_vuln:    .asciiz "WARNING: Unprotected memory access - Direct memory operation\n"
    
    # Exploit messages and data
    exploit_header: .asciiz "\n=== Exploit Simulation ===\n"
    buffer_msg:     .asciiz "Simulating buffer overflow exploit...\n"
    memory_msg:     .asciiz "Simulating memory leak exploit...\n"
    exploit_success: .asciiz "\nExploit successful. Memory contents:\n"
    
    # Educational messages
    buffer_edu:     .asciiz "Buffer overflow occurs when program writes beyond buffer boundaries.\nThis can overwrite adjacent memory and modify program behavior.\n"
    memory_edu:     .asciiz "Memory leaks expose sensitive data stored in memory.\nProper bounds checking and memory protection are essential.\n"
    
    # Storage
    filepath:       .space 256      # Buffer for file path
    code_buffer:    .space 4096     # Buffer for source code
    overflow_payload: .asciiz "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"  # 40 'A's
    vuln_count:     .word 0         # Number of vulnerabilities found
    vuln_types:     .space 16       # Track vulnerability types
    newline:        .asciiz "\n"

    # Constants
    MAX_FILE_SIZE: .word 4096    # Maximum file size we can handle

.text
.globl main

main:
    # Save return address
    addi $sp, $sp, -4
    sw $ra, ($sp)
    
    # Display welcome message
    li $v0, 4
    la $a0, welcome
    syscall
    
    # Load the file first
    jal load_file
    
    # Check for load errors
    bltz $v0, main_exit

menu_loop:
    # Display menu
    li $v0, 4
    la $a0, menu
    syscall
    
    # Get user choice
    li $v0, 5
    syscall
    move $t0, $v0
    
    # Handle menu selection
    beq $t0, 1, display_code
    beq $t0, 2, scan_code
    beq $t0, 3, exploit_menu
    beq $t0, 4, main_exit
    j menu_loop

main_exit:
    lw $ra, ($sp)
    addi $sp, $sp, 4
    j exit_program

load_file:
    # Save registers
    addi $sp, $sp, -12
    sw $ra, 8($sp)
    sw $s0, 4($sp)
    sw $s1, 0($sp)
    
    # Prompt for filename
    li $v0, 4
    la $a0, file_prompt
    syscall
    
    # Read filename
    li $v0, 8
    la $a0, filepath
    li $a1, 256
    syscall
    
    # Remove newline from filename
    la $t0, filepath
remove_newline:
    lb $t1, ($t0)
    beqz $t1, open_file
    beq $t1, 10, replace_newline
    addi $t0, $t0, 1
    j remove_newline
replace_newline:
    sb $zero, ($t0)
    
open_file:
    # Open the file
    li $v0, 13
    la $a0, filepath
    li $a1, 0          # Read-only flag
    li $a2, 0          # Mode (ignored)
    syscall
    
    # Check for errors
    bltz $v0, file_error_handler
    move $s0, $v0      # Save file descriptor
    
    # Read file contents
    li $v0, 14
    move $a0, $s0
    la $a1, code_buffer
    li $a2, 4096
    syscall
    
    # Check read result
    bltz $v0, read_error
    beqz $v0, read_error
    
    # Check file size
    lw $t0, MAX_FILE_SIZE
    bgt $v0, $t0, size_error
    
    move $s1, $v0    # Save bytes read
    
    # Null terminate buffer
    la $t0, code_buffer
    add $t0, $t0, $s1
    sb $zero, ($t0)
    
    # Close file
    li $v0, 16
    move $a0, $s0
    syscall
    
    # Display success message
    li $v0, 4
    la $a0, loading_msg
    syscall
    
    # Return success
    move $v0, $s1
    
load_file_exit:
    # Restore registers
    lw $s1, 0($sp)
    lw $s0, 4($sp)
    lw $ra, 8($sp)
    addi $sp, $sp, 12
    jr $ra

display_code:
    # Show the loaded code
    li $v0, 4
    la $a0, code_buffer
    syscall
    j menu_loop

scan_code:
    # Show scanning message
    li $v0, 4
    la $a0, scan_msg
    syscall

    # Perform scanning
    jal scan_patterns

    # If no vulnerabilities, show message
    lw $t0, vuln_count
    beqz $t0, no_vulnerabilities
    j menu_loop

no_vulnerabilities:
    li $v0, 4
    la $a0, no_vuln_msg
    syscall
    j menu_loop

scan_patterns:
    # Reset vulnerability count
    sw $zero, vuln_count

    la $t0, code_buffer  # Start scanning code buffer
scan_loop:
    lb $t1, ($t0)
    beqz $t1, scan_done  # End of buffer
    li $t2, 46  # '.'
    beq $t1, $t2, check_directive
    li $t2, 115  # 's' for syscall or sw
    beq $t1, $t2, check_syscall_or_sw
    addi $t0, $t0, 1
    j scan_loop

check_directive:
    # Check for ".space"
    lb $t2, 1($t0)
    li $t3, 115  # 's'
    bne $t2, $t3, continue_scan
    lb $t2, 2($t0)
    li $t3, 112  # 'p'
    bne $t2, $t3, continue_scan

    # Parse buffer size
    addi $t0, $t0, 6  # Skip ".space"
    li $t1, 0
parse_size:
    lb $t2, ($t0)
    blt $t2, 48, check_size  # Not a digit
    bgt $t2, 57, check_size
    sub $t2, $t2, 48
    mul $t1, $t1, 10
    add $t1, $t1, $t2
    addi $t0, $t0, 1
    j parse_size
check_size:
    li $t2, 1024
    bgt $t1, $t2, report_buffer_vulnerability
    j continue_scan

check_syscall_or_sw:
    # Check for syscall instruction
    lb $t2, 1($t0)
    li $t3, 121  # 'y' in "syscall"
    bne $t2, $t3, continue_scan
    # Check syscall safety (assuming $v0 holds syscall code)
    lw $t2, 8($t0)  # Simplified: Assume syscall code nearby
    li $t3, 8  # read_string
    beq $t2, $t3, report_syscall_vulnerability
    j continue_scan

report_buffer_vulnerability:
    li $v0, 4
    la $a0, buffer_vuln
    syscall
    lw $t1, vuln_count
    addi $t1, $t1, 1
    sw $t1, vuln_count
    j continue_scan

report_syscall_vulnerability:
    li $v0, 4
    la $a0, syscall_vuln
    syscall
    lw $t1, vuln_count
    addi $t1, $t1, 1
    sw $t1, vuln_count
    j continue_scan

continue_scan:
    addi $t0, $t0, 1
    j scan_loop

scan_done:
    jr $ra 


exploit_menu:
    # Display exploit menu
    li $v0, 4
    la $a0, exploit_menu_text    # Fixed: Using correct label for menu text
    syscall
    
    # Get exploit choice
    li $v0, 5
    syscall
    move $t0, $v0
    
    beq $t0, 1, buffer_exploit
    beq $t0, 2, memory_exploit
    beq $t0, 3, menu_loop
    j exploit_menu

buffer_exploit:
    # Save return address
    addi $sp, $sp, -4
    sw $ra, ($sp)
    
    # Display educational information
    li $v0, 4
    la $a0, buffer_edu
    syscall
    
    # Simulate buffer overflow
    li $v0, 4
    la $a0, buffer_msg
    syscall
    
    # Simulate overflow
    jal simulate_overflow
    
    # Restore return address
    lw $ra, ($sp)
    addi $sp, $sp, 4
    j exploit_menu

memory_exploit:
    # Save return address
    addi $sp, $sp, -4
    sw $ra, ($sp)
    
    # Display educational information
    li $v0, 4
    la $a0, memory_edu
    syscall
    
    # Simulate memory leak
    li $v0, 4
    la $a0, memory_msg
    syscall
    
    # Demonstrate memory exposure
    jal simulate_memory_leak
    
    # Restore return address
    lw $ra, ($sp)
    addi $sp, $sp, 4
    j exploit_menu

simulate_overflow:
    # Save return address
    addi $sp, $sp, -4
    sw $ra, ($sp)
    
    # Display success message
    li $v0, 4
    la $a0, exploit_success
    syscall
    
    # Show simulated overflow effect
    la $a0, overflow_payload
    syscall
    
    # Restore return address
    lw $ra, ($sp)
    addi $sp, $sp, 4
    jr $ra

simulate_memory_leak:
    # Save return address
    addi $sp, $sp, -4
    sw $ra, ($sp)
    
    # Display success message
    li $v0, 4
    la $a0, exploit_success
    syscall
    
    # Show memory contents
    li $t3, 0x12345678    # Example sensitive data
    li $v0, 34            # Print hex
    move $a0, $t3
    syscall
    
    # Print newline
    li $v0, 4
    la $a0, newline
    syscall
    
    # Restore return address
    lw $ra, ($sp)
    addi $sp, $sp, 4
    jr $ra

scan_buffer_overflow:
    # Save return address
    addi $sp, $sp, -4
    sw $ra, ($sp)
    
    # Look for ".space" directive
    la $s0, code_buffer
scan_space_loop:
    lb $t0, ($s0)
    beqz $t0, scan_space_done
    
    # Check for period
    beq $t0, 46, check_space_keyword
    
next_space_char:
    addi $s0, $s0, 1
    j scan_space_loop
    
scan_space_done:
    lw $ra, ($sp)
    addi $sp, $sp, 4
    jr $ra

check_space_keyword:
    # Check if followed by "space"
    lb $t0, 1($s0)
    bne $t0, 115, next_space_char  # 's'
    lb $t0, 2($s0)
    bne $t0, 112, next_space_char  # 'p'
    
    # Found .space directive, report vulnerability
    jal report_buffer_vulnerability
    j next_space_char

scan_syscall_usage:
    # Save return address
    addi $sp, $sp, -4
    sw $ra, ($sp)
    
    # Look for "syscall" instruction
    la $s0, code_buffer
scan_syscall_loop:
    lb $t0, ($s0)
    beqz $t0, scan_syscall_done
    
    # Check for 's'
    beq $t0, 115, check_syscall_keyword
    
next_syscall_char:
    addi $s0, $s0, 1
    j scan_syscall_loop
    
scan_syscall_done:
    lw $ra, ($sp)
    addi $sp, $sp, 4
    jr $ra

check_syscall_keyword:
    # Check if followed by "yscall"
    lb $t0, 1($s0)
    bne $t0, 121, next_syscall_char
    
    # Found syscall, report vulnerability
    jal report_syscall_vulnerability
    j next_syscall_char

scan_memory_ops:
    # Save return address
    addi $sp, $sp, -4
    sw $ra, ($sp)
    
    # Look for memory operations (lw, sw)
    la $s0, code_buffer
scan_mem_loop:
    lb $t0, ($s0)
    beqz $t0, scan_mem_done
    
    # Check for 'l' or 's'
    beq $t0, 108, check_load_op     # 'l'
    beq $t0, 115, check_store_op    # 's'
    
next_mem_char:
    addi $s0, $s0, 1
    j scan_mem_loop
    
scan_mem_done:
    lw $ra, ($sp)
    addi $sp, $sp, 4
    jr $ra

check_load_op:
    lb $t0, 1($s0)
    bne $t0, 119, next_mem_char     # 'w'
    jal report_memory_vulnerability
    j next_mem_char

check_store_op:
    lb $t0, 1($s0)
    bne $t0, 119, next_mem_char     # 'w'
    jal report_memory_vulnerability
    j next_mem_char

.data
    # Pattern definitions
    pattern_buffer:    .space 1024    # Buffer for pattern matching
    pattern_state:     .word 0        # Current pattern matching state
    
    # Pattern types
    PATTERN_BUFFER:    .word 1        # Buffer operation pattern
    PATTERN_SYSCALL:   .word 2        # Syscall pattern
    PATTERN_MEMORY:    .word 3        # Memory operation pattern
    
    # Pattern matching messages
    pattern_found_msg: .asciiz "\nPattern match found: "
    buffer_pattern:    .asciiz "Buffer operation\n"
    syscall_pattern:   .asciiz "Syscall operation\n"
    memory_pattern:    .asciiz "Memory operation\n"

.text
match_patterns:
    # Save registers
    addi $sp, $sp, -24
    sw $ra, 20($sp)
    sw $s4, 16($sp)
    sw $s3, 12($sp)
    sw $s2, 8($sp)
    sw $s1, 4($sp)
    sw $s0, 0($sp)

    # Initialize variables
    la $s0, code_buffer        # Source code pointer
    li $s1, 0                  # $s1: previous instruction (for context)
    li $s2, 0                  # $s2: syscall code
    li $s3, 0                  # $s3: in syscall context flag
    li $s4, 0                  # $s4: in buffer allocation context flag

match_loop:
    lb $t0, ($s0)
    beqz $t0, match_done       # End of code

    # Skip whitespace and comments
    li $t1, '#'
    beq $t0, $t1, skip_comment
    li $t1, ' '
    beq $t0, $t1, next_char
    li $t1, '\t'
    beq $t0, $t1, next_char
    li $t1, '\n'
    beq $t0, $t1, next_char

    # Check for instructions
    li $t1, 'l'                # 'l' character
    beq $t0, $t1, check_li_instruction

    li $t1, 's'                # 's' character
    beq $t0, $t1, check_sw_or_syscall

    li $t1, '.'
    beq $t0, $t1, check_directive

    # Not an instruction we're interested in
    j next_char

skip_comment:
    # Skip the rest of the line
skip_comment_loop:
    lb $t0, ($s0)
    beqz $t0, match_done
    li $t1, '\n'
    beq $t0, $t1, next_char
    addi $s0, $s0, 1
    j skip_comment_loop

check_li_instruction:
    # Check if 'li' instruction (load immediate)
    lb $t1, 1($s0)
    li $t2, 'i'
    bne $t1, $t2, next_char

    # Parse register and value
    # Simplified parsing assuming format: li $reg, value
    # Advance pointer past 'li'
    addi $s0, $s0, 2

    # Skip whitespace
    j skip_whitespace

parse_li_register:
    # Expecting '$v0' for syscall code
    lb $t0, ($s0)
    li $t1, '$'
    bne $t0, $t1, next_char
    lb $t0, 1($s0)
    li $t1, 'v'
    bne $t0, $t1, next_char
    lb $t0, 2($s0)
    li $t1, '0'
    bne $t0, $t1, next_char

    # Found 'li $v0,'
    # Advance pointer past '$v0'
    addi $s0, $s0, 3

    # Skip whitespace and comma
    j skip_whitespace

parse_li_value:
    # Parse the immediate value (syscall code)
    # Simplified parsing assuming single-digit syscall codes
    lb $t0, ($s0)
    blt $t0, '0', next_char
    bgt $t0, '9', next_char
    sub $s2, $t0, '0'      # Store syscall code in $s2

    # Set flag indicating that syscall code is set
    li $s3, 1

    # Advance pointer
    addi $s0, $s0, 1
    j next_char

check_sw_or_syscall:
    # Check if 'syscall' or 'sw' instruction
    lb $t1, 1($s0)
    li $t2, 'y'
    beq $t1, $t2, check_syscall_instruction

    li $t2, 'w'
    beq $t1, $t2, check_memory_instruction

    j next_char

check_syscall_instruction:
    # Check for 'syscall'
    lb $t1, 2($s0)
    li $t2, 's'
    bne $t1, $t2, next_char
    lb $t1, 3($s0)
    li $t2, 'c'
    bne $t1, $t2, next_char
    lb $t1, 4($s0)
    li $t2, 'a'
    bne $t1, $t2, next_char
    lb $t1, 5($s0)
    li $t2, 'l'
    bne $t1, $t2, next_char
    lb $t1, 6($s0)
    li $t2, 'l'
    bne $t1, $t2, next_char

    # 'syscall' instruction found
    # Check if the syscall code is dangerous
    beq $s3, 1, check_syscall_code

    # Reset syscall code flag
    li $s3, 0
    j advance_past_syscall

check_syscall_code:
    # Check if syscall code is one we consider dangerous
    # For example, syscall code 8 (read_string) without proper validation
    li $t0, 8       # read_string
    beq $s2, $t0, report_syscall_vulnerability

    # Other dangerous syscalls can be added here
    # ...

    # Reset syscall code flag
    li $s3, 0
    j advance_past_syscall

report_syscall_vulnerability:
    # Report vulnerability
    li $v0, 4
    la $a0, pattern_found_msg
    syscall
    la $a0, syscall_pattern
    syscall

    # Update vulnerability counter
    jal report_syscall_vulnerability

    # Reset syscall code flag
    li $s3, 0

advance_past_syscall:
    # Advance pointer past 'syscall'
    addi $s0, $s0, 7
    j match_loop

check_memory_instruction:
    # Check for 'sw' instruction
    # We can consider 'sw' and 'lw' potentially unsafe if used improperly
    # For now, we'll assume they're safe (or implement similar context checks)
    # Skip 'sw' instruction
    addi $s0, $s0, 2
    j match_loop

check_directive:
    # Check for '.space' directive
    lb $t1, 1($s0)
    li $t2, 's'
    bne $t1, $t2, next_char
    lb $t1, 2($s0)
    li $t2, 'p'
    bne $t1, $t2, next_char
    lb $t1, 3($s0)
    li $t2, 'a'
    bne $t1, $t2, next_char
    lb $t1, 4($s0)
    li $t2, 'c'
    bne $t1, $t2, next_char
    lb $t1, 5($s0)
    li $t2, 'e'
    bne $t1, $t2, next_char

    # '.space' directive found
    # Parse the allocated size
    # Advance pointer past '.space'
    addi $s0, $s0, 6

    # Skip whitespace
    j skip_whitespace

parse_space_size:
    # Parse the size value
    # Simplified parsing assuming decimal number
    move $s4, $zero     # Initialize size to 0
parse_size_loop:
    lb $t0, ($s0)
    blt $t0, '0', check_space_size
    bgt $t0, '9', check_space_size
    sub $t0, $t0, '0'
    mul $s4, $s4, 10
    add $s4, $s4, $t0
    addi $s0, $s0, 1
    j parse_size_loop

check_space_size:
    # Check if size exceeds threshold (e.g., 1024 bytes)
    li $t0, 1024
    bgt $s4, $t0, report_buffer_vulnerability

    # Continue scanning
    j match_loop

report_buffer_vulnerability:
    # Report vulnerability
    li $v0, 4
    la $a0, pattern_found_msg
    syscall
    la $a0, buffer_pattern
    syscall

    # Update vulnerability counter
    jal report_buffer_vulnerability

    # Continue scanning
    j match_loop

skip_whitespace:
    lb $t0, ($s0)
    li $t1, ' '
    beq $t0, $t1, skip_whitespace_advance
    li $t1, '\t'
    beq $t0, $t1, skip_whitespace_advance
    li $t1, ','
    beq $t0, $t1, skip_whitespace_advance
    j parse_li_register

skip_whitespace_advance:
    addi $s0, $s0, 1
    j skip_whitespace

next_char:
    addi $s0, $s0, 1
    j match_loop

match_done:
    # Restore registers
    lw $s0, 0($sp)
    lw $s1, 4($sp)
    lw $s2, 8($sp)
    lw $s3, 12($sp)
    lw $s4, 16($sp)
    lw $ra, 20($sp)
    addi $sp, $sp, 24
    jr $ra

report_memory_vulnerability:
    # Increment vulnerability counter
    lw $t0, vuln_count
    addi $t0, $t0, 1
    sw $t0, vuln_count
    
    # Report vulnerability
    li $v0, 4
    la $a0, memory_vuln
    syscall
    jr $ra

no_vulnerabilities:
    li $v0, 4
    la $a0, no_vuln_msg
    syscall
    j menu_loop

file_error_handler:
    li $v0, 4
    la $a0, error_msg
    syscall
    li $v0, -1        # Return error code
    j load_file_exit

read_error:
    # Close file first
    li $v0, 16
    move $a0, $s0
    syscall
    
    # Display error message
    li $v0, 4
    la $a0, read_error_msg
    syscall
    li $v0, -1        # Return error code
    j load_file_exit

size_error:
    # Close file first
    li $v0, 16
    move $a0, $s0
    syscall
    
    # Display error message
    li $v0, 4
    la $a0, size_error_msg
    syscall
    li $v0, -1        # Return error code
    j load_file_exit

exit_program:
    li $v0, 10
    syscall